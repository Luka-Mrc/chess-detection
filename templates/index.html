<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chess Position Detector</title>

  <!-- chessboard.js -->
  <link rel="stylesheet"
        href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

  <!-- chess.js â€” SAN conversion and FEN validation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: system-ui, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: #16213e;
      padding: 1rem 2rem;
      border-bottom: 2px solid #0f3460;
    }

    header h1 {
      font-size: 1.5rem;
      color: #e94560;
      letter-spacing: 0.05em;
    }

    .container {
      display: flex;
      flex: 1;
      gap: 2rem;
      padding: 2rem;
      flex-wrap: wrap;
    }

    /* Left panel */
    .left-panel {
      flex: 0 0 280px;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    .card {
      background: #16213e;
      border: 1px solid #0f3460;
      border-radius: 8px;
      padding: 1.25rem;
    }

    .card h2 {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #e94560;
      margin-bottom: 0.75rem;
    }

    /* File input */
    #imageInput {
      display: none;
    }

    .file-label {
      display: block;
      text-align: center;
      padding: 0.6rem 1rem;
      background: #0f3460;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
      font-size: 0.9rem;
    }

    .file-label:hover { background: #e94560; }

    #preview {
      margin-top: 0.75rem;
      width: 100%;
      border-radius: 6px;
      display: none;
      border: 1px solid #0f3460;
    }

    /* Method radios */
    .method-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .method-group label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      padding: 0.4rem 0.6rem;
      border-radius: 6px;
      transition: background 0.15s;
    }

    .method-group label:hover { background: #0f3460; }

    .method-group input[type="radio"] {
      accent-color: #e94560;
    }

    /* Detect button */
    #detectBtn {
      width: 100%;
      padding: 0.75rem;
      background: #e94560;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s, opacity 0.2s;
    }

    #detectBtn:hover:not(:disabled) { background: #c73652; }
    #detectBtn:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Rotate button */
    #rotateBtn {
      width: 100%;
      padding: 0.75rem;
      background: #0f3460;
      color: #e0e0e0;
      border: 1px solid #e94560;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s, opacity 0.2s;
    }

    #rotateBtn:hover:not(:disabled) { background: #1a4a80; }
    #rotateBtn:disabled { opacity: 0.35; cursor: not-allowed; }

    /* Reset button */
    #resetBtn {
      width: 100%;
      padding: 0.75rem;
      background: #0f3460;
      color: #e0e0e0;
      border: 1px solid #0f3460;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s, opacity 0.2s;
    }
    #resetBtn:hover:not(:disabled) { background: #1a4a80; }
    #resetBtn:disabled { opacity: 0.35; cursor: not-allowed; }

    /* Game status */
    #gameStatus { font-size: 0.85rem; color: #a0a0c0; margin-top: 0.5rem; min-height: 1.2em; }
    #gameStatus.check    { color: #ffaa44; font-weight: 600; }
    #gameStatus.checkmate { color: #e94560; font-weight: 600; }
    #gameStatus.draw     { color: #7a7a9a; }

    /* Right panel */
    .right-panel {
      flex: 1;
      min-width: 340px;
      display: flex;
      flex-direction: row;
      gap: 1.25rem;
      align-items: flex-start;
    }

    .board-column {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
      flex: 0 0 auto;
    }

    #board-wrapper {
      width: 480px;
      max-width: 480px;
      position: relative;
    }

    #board {
      width: 100%;
    }

    #arrowCanvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }

    /* Status / FEN display */
    #status-card {
      background: #16213e;
      border: 1px solid #0f3460;
      border-radius: 8px;
      padding: 1.25rem;
      max-width: 480px;
    }

    #status-card h2 {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #e94560;
      margin-bottom: 0.75rem;
    }

    #statusLine {
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    #fenBox {
      font-family: monospace;
      font-size: 0.85rem;
      word-break: break-all;
      background: #0f3460;
      padding: 0.6rem;
      border-radius: 4px;
      display: none;
    }

    .badge {
      display: inline-block;
      padding: 0.2em 0.55em;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .badge-ok  { background: #1a7a4a; color: #a3ffcc; }
    .badge-err { background: #7a1a1a; color: #ffaaaa; }

    /* Spinner */
    .spinner {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: #e94560;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
      vertical-align: middle;
      margin-right: 4px;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    /* Side-to-move toggle */
    .side-toggle { display:flex; border-radius:6px; overflow:hidden; border:1px solid #0f3460; }
    .side-toggle button { flex:1; padding:0.45rem 0; border:none; background:#0f3460; color:#a0a0c0; font-size:0.85rem; cursor:pointer; transition:background 0.15s,color 0.15s; }
    .side-toggle button.active { background:#e94560; color:#fff; font-weight:600; }
    .side-toggle button:hover:not(.active) { background:#1a4a80; color:#e0e0e0; }

    /* Analysis card */
    #analysis-card { background:#16213e; border:1px solid #0f3460; border-radius:8px; padding:1.25rem; min-width:220px; max-width:280px; flex-shrink:0; }
    #analysis-card h2 { font-size:0.85rem; text-transform:uppercase; letter-spacing:0.1em; color:#e94560; margin-bottom:0.75rem; }

    /* Eval bar */
    .eval-bar-wrap { display:flex; align-items:center; gap:0.75rem; margin-bottom:0.85rem; }
    .eval-bar { width:18px; height:160px; border-radius:4px; overflow:hidden; border:1px solid #0f3460; display:flex; flex-direction:column; flex-shrink:0; }
    .eval-bar-white { background:#f0ebe3; transition:flex 0.4s ease; }
    .eval-bar-black { background:#2a2a2a; transition:flex 0.4s ease; }
    .eval-score-label { font-size:1.1rem; font-weight:700; color:#e0e0e0; font-family:monospace; min-width:60px; }

    /* Moves table */
    .moves-table { width:100%; border-collapse:collapse; }
    .moves-table th { font-size:0.75rem; text-transform:uppercase; letter-spacing:0.08em; color:#7a7a9a; padding:0.3rem 0.5rem; text-align:left; border-bottom:1px solid #0f3460; }
    .moves-table td { padding:0.45rem 0.5rem; font-size:0.9rem; border-bottom:1px solid rgba(15,52,96,0.5); }
    .moves-table td:first-child { color:#7a7a9a; font-size:0.8rem; width:28px; }
    .move-san { font-family:monospace; font-weight:600; color:#e0e0e0; }
    .move-score { text-align:right; font-family:monospace; font-size:0.85rem; color:#a0c4ff; }
  </style>
</head>
<body>

<header>
  <h1>Chess Position Detector</h1>
</header>

<div class="container">

  <!-- Left panel -->
  <div class="left-panel">

    <div class="card">
      <h2>Image</h2>
      <label class="file-label" for="imageInput">
        ðŸ“· Upload / Capture
      </label>
      <input type="file" id="imageInput" accept="image/*" capture="environment">
      <img id="preview" alt="Preview">
    </div>

    <div class="card">
      <h2>Detection Method</h2>
      <div class="method-group">
        <label>
          <input type="radio" name="method" value="canny" checked>
          Canny (classical edge)
        </label>
        <label>
          <input type="radio" name="method" value="hough">
          Hough (line transform)
        </label>
        <label>
          <input type="radio" name="method" value="dnn">
          DNN (X-corner classifier)
        </label>
      </div>
    </div>

    <div class="card">
      <h2>Side to Move</h2>
      <div class="side-toggle">
        <button id="sideWhite" class="active" type="button">White</button>
        <button id="sideBlack" type="button">Black</button>
      </div>
    </div>

    <button id="detectBtn" disabled>Detect Position</button>
    <button id="rotateBtn" disabled>&#8635; Rotate 90Â°</button>
    <button id="resetBtn"  disabled>&#8617; Reset Position</button>

  </div>

  <!-- Right panel -->
  <div class="right-panel">

    <div class="board-column">
      <div id="board-wrapper">
        <div id="board"></div>
        <canvas id="arrowCanvas"></canvas>
      </div>

      <div id="status-card">
        <h2>Result</h2>
        <p id="statusLine">Upload an image and click Detect.</p>
        <div id="fenBox"></div>
        <p id="gameStatus"></p>
      </div>
    </div>

    <div id="analysis-card">
      <h2>Engine Analysis</h2>
      <div id="analysis-placeholder" style="font-size:0.85rem;color:#7a7a9a;">
        Upload an image and detect a position to run analysis.
      </div>
      <div id="analysis-content" style="display:none;">
        <div class="eval-bar-wrap">
          <div class="eval-bar">
            <div class="eval-bar-white" id="evalBarWhite" style="flex:50;"></div>
            <div class="eval-bar-black" id="evalBarBlack" style="flex:50;"></div>
          </div>
          <div>
            <div class="eval-score-label" id="evalScoreLabel">0.00</div>
            <div style="font-size:0.72rem;color:#7a7a9a;margin-top:0.25rem;" id="evalDepthLabel"></div>
          </div>
        </div>
        <table class="moves-table">
          <thead><tr><th>#</th><th>Move</th><th style="text-align:right;">Score</th></tr></thead>
          <tbody id="movesBody"></tbody>
        </table>
      </div>
    </div>

  </div>
</div>

<!-- jQuery (required by chessboard.js) -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<!-- chessboard.js â€” use jsDelivr which reliably serves npm package files -->
<script src="https://cdn.jsdelivr.net/npm/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>

<script>
  // â”€â”€ Board setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const board = Chessboard('board', {
    position:    'empty',
    pieceTheme:  'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
    draggable:   true,
    onDragStart: onDragStart,
    onDrop:      onDrop,
    onSnapEnd:   onSnapEnd,
  });

  window.addEventListener('resize', board.resize);

  // â”€â”€ DOM refs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const imageInput = document.getElementById('imageInput');
  const preview    = document.getElementById('preview');
  const detectBtn  = document.getElementById('detectBtn');
  const rotateBtn  = document.getElementById('rotateBtn');
  const resetBtn   = document.getElementById('resetBtn');
  const statusLine = document.getElementById('statusLine');
  const fenBox     = document.getElementById('fenBox');
  const gameStatus = document.getElementById('gameStatus');

  // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let selectedFile    = null;
  let currentPosition = null; // chessboard.js position object
  let game            = null; // chess.js instance (tracks legal game state)
  let detectedFen     = null; // piece-placement FEN of last successful detection

  // â”€â”€ Drag handlers (chess.js enforces legality) â”€â”€â”€â”€â”€

  function onDragStart(source, piece) {
    // Disable dragging if no game loaded or game is over
    if (!game || game.game_over()) return false;
    // Only allow the side whose turn it is
    if (game.turn() === 'w' && piece.search(/^b/) !== -1) return false;
    if (game.turn() === 'b' && piece.search(/^w/) !== -1) return false;
    return true;
  }

  function onDrop(source, target) {
    if (!game) return 'snapback';
    // Attempt the move; chess.js validates full legality (pins, blocking, etc.)
    const move = game.move({ from: source, to: target, promotion: 'q' });
    if (!move) return 'snapback'; // illegal â€” snap piece back
    updateGameStatus();
    // Re-analyse with the new position; pass next side so toggle stays in sync
    window.analyzePosition(game.fen().split(' ')[0], game.turn());
  }

  function onSnapEnd() {
    // Sync board display with chess.js state after animation
    if (game) board.position(game.fen());
  }

  // â”€â”€ Game status line â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function updateGameStatus() {
    if (!game) { gameStatus.textContent = ''; gameStatus.className = ''; return; }
    gameStatus.className = '';
    if (game.in_checkmate()) {
      gameStatus.textContent = (game.turn() === 'w' ? 'Black' : 'White') + ' wins by checkmate';
      gameStatus.classList.add('checkmate');
    } else if (game.in_draw()) {
      gameStatus.textContent = 'Draw';
      gameStatus.classList.add('draw');
    } else if (game.in_check()) {
      gameStatus.textContent = (game.turn() === 'w' ? 'White' : 'Black') + ' is in check';
      gameStatus.classList.add('check');
    } else {
      gameStatus.textContent = (game.turn() === 'w' ? 'White' : 'Black') + ' to move';
    }
  }

  // â”€â”€ FEN / position helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Piece-placement FEN â†’ chessboard.js position object
  function fenToPos(fen) {
    const pieceMap = {
      P:'wP', R:'wR', N:'wN', B:'wB', Q:'wQ', K:'wK',
      p:'bP', r:'bR', n:'bN', b:'bB', q:'bQ', k:'bK',
    };
    const pos   = {};
    const ranks = fen.split('/');
    for (let ri = 0; ri < 8; ri++) {
      const rankNum = 8 - ri;
      let col = 0;
      for (const ch of ranks[ri]) {
        if (ch >= '1' && ch <= '8') { col += parseInt(ch); }
        else {
          if (pieceMap[ch]) pos[String.fromCharCode(97 + col) + rankNum] = pieceMap[ch];
          col++;
        }
      }
    }
    return pos;
  }

  // chessboard.js position object â†’ piece-placement FEN
  function posToFen(pos) {
    const pieceMap = {
      wP:'P', wR:'R', wN:'N', wB:'B', wQ:'Q', wK:'K',
      bP:'p', bR:'r', bN:'n', bB:'b', bQ:'q', bK:'k',
    };
    let fen = '';
    for (let r = 8; r >= 1; r--) {
      let empty = 0;
      for (let f = 0; f < 8; f++) {
        const piece = pos[String.fromCharCode(97 + f) + r];
        if (piece) { if (empty) { fen += empty; empty = 0; } fen += pieceMap[piece] || ''; }
        else { empty++; }
      }
      if (empty) fen += empty;
      if (r > 1) fen += '/';
    }
    return fen;
  }

  // Rotate position 90Â° clockwise (for orientation correction)
  function rotateCW90(pos) {
    const newPos = {};
    for (const [sq, piece] of Object.entries(pos)) {
      const fi = sq.charCodeAt(0) - 97;
      const r  = parseInt(sq[1]);
      newPos[String.fromCharCode(97 + r - 1) + (8 - fi)] = piece;
    }
    return newPos;
  }

  // Read which side is active in the toggle
  function currentSide() {
    return document.getElementById('sideWhite').classList.contains('active') ? 'w' : 'b';
  }

  // â”€â”€ Event listeners â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  imageInput.addEventListener('change', () => {
    selectedFile = imageInput.files[0];
    if (!selectedFile) return;
    preview.src = URL.createObjectURL(selectedFile);
    preview.style.display = 'block';
    detectBtn.disabled = false;
  });

  rotateBtn.addEventListener('click', () => {
    if (!currentPosition) return;
    currentPosition = rotateCW90(currentPosition);
    board.position(currentPosition, false);
    const newFen = posToFen(currentPosition);
    detectedFen  = newFen;
    game = new Chess(newFen + ' ' + currentSide() + ' - - 0 1');
    updateGameStatus();
  });

  resetBtn.addEventListener('click', () => {
    if (!detectedFen) return;
    const side = currentSide();
    game = new Chess(detectedFen + ' ' + side + ' - - 0 1');
    currentPosition = fenToPos(detectedFen);
    board.position(currentPosition, false);
    updateGameStatus();
    window.analyzePosition(detectedFen, side);
  });

  detectBtn.addEventListener('click', async () => {
    if (!selectedFile) return;

    const method = document.querySelector('input[name="method"]:checked').value;

    detectBtn.disabled = true;
    rotateBtn.disabled = true;
    resetBtn.disabled  = true;
    detectBtn.innerHTML = '<span class="spinner"></span>Detecting\u2026';
    statusLine.innerHTML = 'Running pipeline\u2026';
    fenBox.style.display = 'none';
    gameStatus.textContent = '';
    gameStatus.className   = '';

    const formData = new FormData();
    formData.append('image', selectedFile);
    formData.append('method', method);

    try {
      const resp = await fetch('/detect', { method: 'POST', body: formData });
      const data = await resp.json();

      if (!resp.ok) {
        statusLine.innerHTML = `<span class="badge badge-err">Error</span> ${data.error || 'Server error'}`;
        board.position('empty');
        currentPosition = null;
        game = null;
      } else {
        statusLine.innerHTML = data.success
          ? '<span class="badge badge-ok">Board found</span>'
          : '<span class="badge badge-err">Board not found</span>';

        if (data.fen) {
          const side      = currentSide();
          currentPosition = fenToPos(data.fen);
          board.position(currentPosition, false);
          fenBox.textContent   = data.fen;
          fenBox.style.display = 'block';
          detectedFen = data.fen;
          game = new Chess(data.fen + ' ' + side + ' - - 0 1');
          updateGameStatus();
          analyzePosition(data.fen);      // side comes from toggle
          rotateBtn.disabled = false;
          resetBtn.disabled  = false;
        } else {
          board.position('empty');
          fenBox.style.display = 'none';
          currentPosition = null;
          game = null;
        }

        if (!data.success) {
          statusLine.innerHTML += ' \u2014 board detection failed; piece squares may be incorrect.';
        }
      }
    } catch (err) {
      statusLine.innerHTML = `<span class="badge badge-err">Error</span> ${err.message}`;
      board.position('empty');
      currentPosition = null;
      game = null;
    } finally {
      detectBtn.disabled = false;
      detectBtn.textContent = 'Detect Position';
    }
  });
</script>

<script>
/* ====================================================
   Stockfish.js engine analysis
   ==================================================== */
(function () {
  'use strict';

  // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let engine         = null;
  let engineReady    = false;
  let currentFen     = null;  // piece-placement FEN being analysed
  let pendingResults = {};    // multipv index â†’ best info at current depth
  let latestDepth    = 0;
  let analysisId     = 0;     // incremented on every new analyzePosition call;
                              // guards against stale engine messages arriving
                              // after the position has changed.

  // â”€â”€ DOM refs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const analysisPlaceholder = document.getElementById('analysis-placeholder');
  const analysisContent     = document.getElementById('analysis-content');
  const evalBarWhite        = document.getElementById('evalBarWhite');
  const evalBarBlack        = document.getElementById('evalBarBlack');
  const evalScoreLabel      = document.getElementById('evalScoreLabel');
  const evalDepthLabel      = document.getElementById('evalDepthLabel');
  const movesBody           = document.getElementById('movesBody');
  const sideWhiteBtn        = document.getElementById('sideWhite');
  const sideBlackBtn        = document.getElementById('sideBlack');
  const arrowCanvas         = document.getElementById('arrowCanvas');
  const arrowCtx            = arrowCanvas.getContext('2d');

  // â”€â”€ Side-to-move toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let sideToMove = 'w';

  sideWhiteBtn.addEventListener('click', () => {
    sideToMove = 'w';
    sideWhiteBtn.classList.add('active');
    sideBlackBtn.classList.remove('active');
    if (currentFen) window.analyzePosition(currentFen, 'w');
  });

  sideBlackBtn.addEventListener('click', () => {
    sideToMove = 'b';
    sideBlackBtn.classList.add('active');
    sideWhiteBtn.classList.remove('active');
    if (currentFen) window.analyzePosition(currentFen, 'b');
  });

  // â”€â”€ Engine init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function initEngine() {
    try {
      engine = new Worker('/static/stockfish.js');
    } catch (e) {
      console.error('Could not create Stockfish worker:', e);
      return;
    }
    engine.onmessage = handleEngineMessage;
    engine.postMessage('uci');
    engine.postMessage('setoption name MultiPV value 3');
    engine.postMessage('isready');
  }

  // â”€â”€ Message handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Each message is tagged with the analysisId that was current when the
  // search started. Messages from a superseded search are discarded.
  function handleEngineMessage(event) {
    const line = typeof event === 'string' ? event : (event.data || '');

    if (line === 'readyok') { engineReady = true; return; }

    // Messages carry a closured copy of the id at search start.
    // We extract it from a sentinel prefix we inject (see analyzePosition).
    // Simpler: we just use the global analysisId captured in the closure per call.
    // The message handler is replaced per search â€” no, that's complex.
    // Instead: store the running id inside the message via a comment trick.
    // Simplest correct approach: parse the id out of a custom "searchid" info line.
    // â€”â€”â€” We use a closure variable approach: each call increments analysisId
    //     and captures it in a local `myId` variable. We pass myId into a
    //     per-call message handler installed temporarily. Instead, we use the
    //     module-level `analysisId` and compare inside the handler.

    if (line.startsWith('info') && line.includes('multipv')) {
      parseInfoLine(line);
      return;
    }

    if (line.startsWith('bestmove')) {
      renderResults();
    }
  }

  // â”€â”€ Parse UCI info line â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function parseInfoLine(line) {
    const depthMatch   = line.match(/\bdepth (\d+)/);
    const multipvMatch = line.match(/\bmultipv (\d+)/);
    const cpMatch      = line.match(/\bscore cp (-?\d+)/);
    const mateMatch    = line.match(/\bscore mate (-?\d+)/);
    const pvMatch      = line.match(/\bpv ([a-h][1-8][a-h][1-8][qrbn]?)/);

    if (!multipvMatch || !pvMatch) return;

    const depth = depthMatch ? parseInt(depthMatch[1]) : 0;
    const mpv   = parseInt(multipvMatch[1]);
    const move  = pvMatch[1];

    // Discard results that belong to a previous search (stale messages that
    // arrived after engine.postMessage('stop') but before the worker flushed).
    if (depth <= latestDepth && mpv in pendingResults) return;
    if (depth > latestDepth) {
      // New deeper result â€” update tracker and clear shallower data
      latestDepth = depth;
    }

    let score = cpMatch   ? parseInt(cpMatch[1])   : null;
    let mate  = mateMatch ? parseInt(mateMatch[1]) : null;

    // Convert to White's POV
    if (score !== null && sideToMove === 'b') score = -score;
    if (mate  !== null && sideToMove === 'b') mate  = -mate;

    // SAN conversion via chess.js for the move table
    let san = move;
    try {
      const chess  = new Chess(currentFen + ' ' + sideToMove + ' - - 0 1');
      const result = chess.move({ from: move.slice(0, 2), to: move.slice(2, 4), promotion: move[4] || 'q' });
      if (result) san = result.san;
    } catch (e) { /* keep UCI notation as fallback */ }

    pendingResults[mpv] = { depth, move, san, score, mate };
    evalDepthLabel.textContent = 'depth ' + depth;
  }

  // â”€â”€ Arrow drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let lastArrowMoves = [];

  function squareCenter(sq, boardSize) {
    const sqSize = boardSize / 8;
    return {
      x: (sq.charCodeAt(0) - 97 + 0.5) * sqSize,
      y: (8 - parseInt(sq[1]) + 0.5) * sqSize,
    };
  }

  function drawArrowShape(ctx, x1, y1, x2, y2, color, alpha, lw) {
    const angle   = Math.atan2(y2 - y1, x2 - x1);
    const headLen = lw * 2.8;
    const tx = x2 - Math.cos(angle) * headLen * 0.85;
    const ty = y2 - Math.sin(angle) * headLen * 0.85;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = color;
    ctx.fillStyle   = color;
    ctx.lineWidth   = lw;
    ctx.lineCap     = 'round';

    ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(tx, ty); ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 5),
               y2 - headLen * Math.sin(angle - Math.PI / 5));
    ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 5),
               y2 - headLen * Math.sin(angle + Math.PI / 5));
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawArrows(moves) {
    lastArrowMoves = moves;
    const size = document.getElementById('board').offsetWidth;
    arrowCanvas.width  = size;
    arrowCanvas.height = size;
    arrowCtx.clearRect(0, 0, size, size);

    const sq = size / 8;
    const styles = [
      { color: '#15781B', alpha: 0.88, lw: sq * 0.18 },
      { color: '#0057e7', alpha: 0.65, lw: sq * 0.13 },
      { color: '#0057e7', alpha: 0.42, lw: sq * 0.10 },
    ];

    moves.forEach(function (m, i) {
      if (i >= styles.length) return;
      const from = squareCenter(m.from, size);
      const to   = squareCenter(m.to,   size);
      const s    = styles[i];
      drawArrowShape(arrowCtx, from.x, from.y, to.x, to.y, s.color, s.alpha, s.lw);
    });
  }

  function clearArrows() {
    lastArrowMoves = [];
    arrowCtx.clearRect(0, 0, arrowCanvas.width, arrowCanvas.height);
  }

  window.addEventListener('resize', function () {
    if (lastArrowMoves.length) drawArrows(lastArrowMoves);
  });

  // â”€â”€ Render final results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function renderResults() {
    const keys = Object.keys(pendingResults).map(Number).sort(function (a, b) { return a - b; });
    if (!keys.length) return;

    analysisPlaceholder.style.display = 'none';
    analysisContent.style.display     = 'block';

    const best = pendingResults[keys[0]];
    const cp   = best.mate !== null
      ? (best.mate > 0 ? 1000 : -1000)
      : (best.score !== null ? best.score : 0);

    const whitePct = (Math.min(Math.max(cp, -1000), 1000) + 1000) / 2000 * 100;
    evalBarWhite.style.flex = String(whitePct);
    evalBarBlack.style.flex = String(100 - whitePct);

    evalScoreLabel.textContent = best.mate !== null
      ? 'M' + Math.abs(best.mate)
      : (best.score >= 0 ? '+' : '') + (best.score / 100).toFixed(2);

    movesBody.innerHTML = '';
    keys.forEach(function (k, i) {
      const r = pendingResults[k];
      const scoreText = r.mate !== null
        ? 'M' + Math.abs(r.mate)
        : ((r.score >= 0 ? '+' : '') + (r.score / 100).toFixed(2));
      const tr = document.createElement('tr');
      tr.innerHTML =
        '<td>' + (i + 1) + '</td>' +
        '<td><span class="move-san">' + r.san + '</span></td>' +
        '<td class="move-score">' + scoreText + '</td>';
      movesBody.appendChild(tr);
    });

    evalDepthLabel.textContent = 'depth ' + best.depth + ' \u2014 done';

    drawArrows(keys.map(function (k) {
      const mv = pendingResults[k].move;
      return { from: mv.slice(0, 2), to: mv.slice(2, 4) };
    }));
  }

  // â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // `side` is optional ('w'|'b'). When provided (e.g. after a move) it
  // overrides the toggle and keeps the UI in sync with chess.js game state.
  window.analyzePosition = function (piecePlacementFen, side) {
    // Sync side-to-move if caller specifies it
    if (side !== undefined && side !== sideToMove) {
      sideToMove = side;
      if (side === 'w') {
        sideWhiteBtn.classList.add('active');
        sideBlackBtn.classList.remove('active');
      } else {
        sideBlackBtn.classList.add('active');
        sideWhiteBtn.classList.remove('active');
      }
    }

    // Bump version â€” any pending engine messages with depth comparisons
    // that write into pendingResults will now produce a fresh, isolated result set.
    analysisId++;
    currentFen     = piecePlacementFen;
    pendingResults = {};
    latestDepth    = 0;

    clearArrows();
    analysisPlaceholder.style.display = 'none';
    analysisContent.style.display     = 'block';
    evalDepthLabel.textContent        = 'depth 0';
    evalScoreLabel.textContent        = '\u2026';
    movesBody.innerHTML               = '';

    if (!engineReady) {
      evalDepthLabel.textContent = 'Engine loading\u2026';
      const capturedSide = sideToMove;
      setTimeout(function () { window.analyzePosition(piecePlacementFen, capturedSide); }, 500);
      return;
    }

    const fullFen = piecePlacementFen + ' ' + sideToMove + ' - - 0 1';
    engine.postMessage('stop');
    engine.postMessage('position fen ' + fullFen);
    engine.postMessage('go depth 15');
  };

  // â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  initEngine();
})();
</script>

</body>
</html>
