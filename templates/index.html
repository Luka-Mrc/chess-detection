<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chess Position Detector</title>

  <!-- chessboard.js -->
  <link rel="stylesheet"
        href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

  <!-- chess.js â€” SAN conversion and FEN validation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: system-ui, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: #16213e;
      padding: 1rem 2rem;
      border-bottom: 2px solid #0f3460;
    }

    header h1 {
      font-size: 1.5rem;
      color: #e94560;
      letter-spacing: 0.05em;
    }

    .container {
      display: flex;
      flex: 1;
      gap: 2rem;
      padding: 2rem;
      flex-wrap: wrap;
    }

    /* Left panel */
    .left-panel {
      flex: 0 0 280px;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    .card {
      background: #16213e;
      border: 1px solid #0f3460;
      border-radius: 8px;
      padding: 1.25rem;
    }

    .card h2 {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #e94560;
      margin-bottom: 0.75rem;
    }

    /* File input */
    #imageInput {
      display: none;
    }

    .file-label {
      display: block;
      text-align: center;
      padding: 0.6rem 1rem;
      background: #0f3460;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
      font-size: 0.9rem;
    }

    .file-label:hover { background: #e94560; }

    #preview {
      margin-top: 0.75rem;
      width: 100%;
      border-radius: 6px;
      display: none;
      border: 1px solid #0f3460;
    }

    /* Method radios */
    .method-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .method-group label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      padding: 0.4rem 0.6rem;
      border-radius: 6px;
      transition: background 0.15s;
    }

    .method-group label:hover { background: #0f3460; }

    .method-group input[type="radio"] {
      accent-color: #e94560;
    }

    /* Detect button */
    #detectBtn {
      width: 100%;
      padding: 0.75rem;
      background: #e94560;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s, opacity 0.2s;
    }

    #detectBtn:hover:not(:disabled) { background: #c73652; }
    #detectBtn:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Rotate button */
    #rotateBtn {
      width: 100%;
      padding: 0.75rem;
      background: #0f3460;
      color: #e0e0e0;
      border: 1px solid #e94560;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s, opacity 0.2s;
    }

    #rotateBtn:hover:not(:disabled) { background: #1a4a80; }
    #rotateBtn:disabled { opacity: 0.35; cursor: not-allowed; }

    /* Right panel */
    .right-panel {
      flex: 1;
      min-width: 340px;
      display: flex;
      flex-direction: row;
      gap: 1.25rem;
      align-items: flex-start;
    }

    .board-column {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
      flex: 0 0 auto;
    }

    #board-wrapper {
      width: 480px;
      max-width: 480px;
      position: relative;
    }

    #board {
      width: 100%;
    }

    #arrowCanvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }

    /* Status / FEN display */
    #status-card {
      background: #16213e;
      border: 1px solid #0f3460;
      border-radius: 8px;
      padding: 1.25rem;
      max-width: 480px;
    }

    #status-card h2 {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #e94560;
      margin-bottom: 0.75rem;
    }

    #statusLine {
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    #fenBox {
      font-family: monospace;
      font-size: 0.85rem;
      word-break: break-all;
      background: #0f3460;
      padding: 0.6rem;
      border-radius: 4px;
      display: none;
    }

    .badge {
      display: inline-block;
      padding: 0.2em 0.55em;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .badge-ok  { background: #1a7a4a; color: #a3ffcc; }
    .badge-err { background: #7a1a1a; color: #ffaaaa; }

    /* Spinner */
    .spinner {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: #e94560;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
      vertical-align: middle;
      margin-right: 4px;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    /* Side-to-move toggle */
    .side-toggle { display:flex; border-radius:6px; overflow:hidden; border:1px solid #0f3460; }
    .side-toggle button { flex:1; padding:0.45rem 0; border:none; background:#0f3460; color:#a0a0c0; font-size:0.85rem; cursor:pointer; transition:background 0.15s,color 0.15s; }
    .side-toggle button.active { background:#e94560; color:#fff; font-weight:600; }
    .side-toggle button:hover:not(.active) { background:#1a4a80; color:#e0e0e0; }

    /* Analysis card */
    #analysis-card { background:#16213e; border:1px solid #0f3460; border-radius:8px; padding:1.25rem; min-width:220px; max-width:280px; flex-shrink:0; }
    #analysis-card h2 { font-size:0.85rem; text-transform:uppercase; letter-spacing:0.1em; color:#e94560; margin-bottom:0.75rem; }

    /* Eval bar */
    .eval-bar-wrap { display:flex; align-items:center; gap:0.75rem; margin-bottom:0.85rem; }
    .eval-bar { width:18px; height:160px; border-radius:4px; overflow:hidden; border:1px solid #0f3460; display:flex; flex-direction:column; flex-shrink:0; }
    .eval-bar-white { background:#f0ebe3; transition:flex 0.4s ease; }
    .eval-bar-black { background:#2a2a2a; transition:flex 0.4s ease; }
    .eval-score-label { font-size:1.1rem; font-weight:700; color:#e0e0e0; font-family:monospace; min-width:60px; }

    /* Moves table */
    .moves-table { width:100%; border-collapse:collapse; }
    .moves-table th { font-size:0.75rem; text-transform:uppercase; letter-spacing:0.08em; color:#7a7a9a; padding:0.3rem 0.5rem; text-align:left; border-bottom:1px solid #0f3460; }
    .moves-table td { padding:0.45rem 0.5rem; font-size:0.9rem; border-bottom:1px solid rgba(15,52,96,0.5); }
    .moves-table td:first-child { color:#7a7a9a; font-size:0.8rem; width:28px; }
    .move-san { font-family:monospace; font-weight:600; color:#e0e0e0; }
    .move-score { text-align:right; font-family:monospace; font-size:0.85rem; color:#a0c4ff; }
  </style>
</head>
<body>

<header>
  <h1>Chess Position Detector</h1>
</header>

<div class="container">

  <!-- Left panel -->
  <div class="left-panel">

    <div class="card">
      <h2>Image</h2>
      <label class="file-label" for="imageInput">
        ðŸ“· Upload / Capture
      </label>
      <input type="file" id="imageInput" accept="image/*" capture="environment">
      <img id="preview" alt="Preview">
    </div>

    <div class="card">
      <h2>Detection Method</h2>
      <div class="method-group">
        <label>
          <input type="radio" name="method" value="canny" checked>
          Canny (classical edge)
        </label>
        <label>
          <input type="radio" name="method" value="hough">
          Hough (line transform)
        </label>
        <label>
          <input type="radio" name="method" value="dnn">
          DNN (X-corner classifier)
        </label>
      </div>
    </div>

    <div class="card">
      <h2>Side to Move</h2>
      <div class="side-toggle">
        <button id="sideWhite" class="active" type="button">White</button>
        <button id="sideBlack" type="button">Black</button>
      </div>
    </div>

    <button id="detectBtn" disabled>Detect Position</button>
    <button id="rotateBtn" disabled>&#8635; Rotate 90Â°</button>

  </div>

  <!-- Right panel -->
  <div class="right-panel">

    <div class="board-column">
      <div id="board-wrapper">
        <div id="board"></div>
        <canvas id="arrowCanvas"></canvas>
      </div>

      <div id="status-card">
        <h2>Result</h2>
        <p id="statusLine">Upload an image and click Detect.</p>
        <div id="fenBox"></div>
      </div>
    </div>

    <div id="analysis-card">
      <h2>Engine Analysis</h2>
      <div id="analysis-placeholder" style="font-size:0.85rem;color:#7a7a9a;">
        Upload an image and detect a position to run analysis.
      </div>
      <div id="analysis-content" style="display:none;">
        <div class="eval-bar-wrap">
          <div class="eval-bar">
            <div class="eval-bar-white" id="evalBarWhite" style="flex:50;"></div>
            <div class="eval-bar-black" id="evalBarBlack" style="flex:50;"></div>
          </div>
          <div>
            <div class="eval-score-label" id="evalScoreLabel">0.00</div>
            <div style="font-size:0.72rem;color:#7a7a9a;margin-top:0.25rem;" id="evalDepthLabel"></div>
          </div>
        </div>
        <table class="moves-table">
          <thead><tr><th>#</th><th>Move</th><th style="text-align:right;">Score</th></tr></thead>
          <tbody id="movesBody"></tbody>
        </table>
      </div>
    </div>

  </div>
</div>

<!-- jQuery (required by chessboard.js) -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<!-- chessboard.js â€” use jsDelivr which reliably serves npm package files -->
<script src="https://cdn.jsdelivr.net/npm/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>

<script>
  const board = Chessboard('board', {
  position: 'empty',
  pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
});

  window.addEventListener('resize', board.resize);

  const imageInput = document.getElementById('imageInput');
  const preview    = document.getElementById('preview');
  const detectBtn  = document.getElementById('detectBtn');
  const rotateBtn  = document.getElementById('rotateBtn');
  const statusLine = document.getElementById('statusLine');
  const fenBox     = document.getElementById('fenBox');

  let selectedFile    = null;
  let currentPosition = null; // chessboard.js position object { a1: 'wR', ... }

  // Parse the pipeline's piece-placement FEN into a chessboard.js position object.
  function fenToPos(fen) {
    const pieceMap = {
      'P': 'wP', 'R': 'wR', 'N': 'wN', 'B': 'wB', 'Q': 'wQ', 'K': 'wK',
      'p': 'bP', 'r': 'bR', 'n': 'bN', 'b': 'bB', 'q': 'bQ', 'k': 'bK',
    };
    const pos   = {};
    const ranks = fen.split('/');
    for (let ri = 0; ri < 8; ri++) {
      const rankNum = 8 - ri;
      let col = 0;
      for (const ch of ranks[ri]) {
        if (ch >= '1' && ch <= '8') {
          col += parseInt(ch);
        } else {
          if (pieceMap[ch]) pos[String.fromCharCode(97 + col) + rankNum] = pieceMap[ch];
          col++;
        }
      }
    }
    return pos;
  }

  // Rotate all piece positions 90Â° clockwise.
  // (file_idx, rank) â†’ (rank-1, 8-file_idx)
  // Corners: a1â†’a8, a8â†’h8, h8â†’h1, h1â†’a1. Four clicks = full rotation.
  function rotateCW90(pos) {
    const newPos = {};
    for (const [sq, piece] of Object.entries(pos)) {
      const fileIdx = sq.charCodeAt(0) - 97;
      const rank    = parseInt(sq[1]);
      newPos[String.fromCharCode(97 + rank - 1) + (8 - fileIdx)] = piece;
    }
    return newPos;
  }

  imageInput.addEventListener('change', () => {
    selectedFile = imageInput.files[0];
    if (!selectedFile) return;
    preview.src = URL.createObjectURL(selectedFile);
    preview.style.display = 'block';
    detectBtn.disabled = false;
  });

  rotateBtn.addEventListener('click', () => {
    if (!currentPosition) return;
    currentPosition = rotateCW90(currentPosition);
    board.position(currentPosition, false);
  });

  detectBtn.addEventListener('click', async () => {
    if (!selectedFile) return;

    const method = document.querySelector('input[name="method"]:checked').value;

    detectBtn.disabled = true;
    rotateBtn.disabled = true;
    detectBtn.innerHTML = '<span class="spinner"></span>Detecting\u2026';
    statusLine.innerHTML = 'Running pipeline\u2026';
    fenBox.style.display = 'none';

    const formData = new FormData();
    formData.append('image', selectedFile);
    formData.append('method', method);

    try {
      const resp = await fetch('/detect', { method: 'POST', body: formData });
      const data = await resp.json();

      if (!resp.ok) {
        statusLine.innerHTML = `<span class="badge badge-err">Error</span> ${data.error || 'Server error'}`;
        board.position('empty');
        currentPosition = null;
      } else {
        statusLine.innerHTML = data.success
          ? '<span class="badge badge-ok">Board found</span>'
          : '<span class="badge badge-err">Board not found</span>';

        if (data.fen) {
          currentPosition = fenToPos(data.fen);
          board.position(currentPosition, false);
          fenBox.textContent = data.fen;
          fenBox.style.display = 'block';
          analyzePosition(data.fen);
          rotateBtn.disabled = false;
        } else {
          board.position('empty');
          fenBox.style.display = 'none';
          currentPosition = null;
        }

        if (!data.success) {
          statusLine.innerHTML += ' \u2014 board detection failed; piece squares may be incorrect.';
        }
      }
    } catch (err) {
      statusLine.innerHTML = `<span class="badge badge-err">Error</span> ${err.message}`;
      board.position('empty');
      currentPosition = null;
    } finally {
      detectBtn.disabled = false;
      detectBtn.textContent = 'Detect Position';
    }
  });
</script>

<script>
/* ====================================================
   Stockfish.js engine analysis
   ==================================================== */
(function () {
  'use strict';

  // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let engine          = null;
  let engineReady     = false;
  let currentFen      = null;   // piece-placement FEN from last detection
  let pendingResults  = {};     // multipv index â†’ best info at current depth
  let latestDepth     = 0;

  // â”€â”€ DOM refs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const analysisPlaceholder = document.getElementById('analysis-placeholder');
  const analysisContent     = document.getElementById('analysis-content');
  const evalBarWhite        = document.getElementById('evalBarWhite');
  const evalBarBlack        = document.getElementById('evalBarBlack');
  const evalScoreLabel      = document.getElementById('evalScoreLabel');
  const evalDepthLabel      = document.getElementById('evalDepthLabel');
  const movesBody           = document.getElementById('movesBody');
  const sideWhiteBtn        = document.getElementById('sideWhite');
  const sideBlackBtn        = document.getElementById('sideBlack');
  const arrowCanvas         = document.getElementById('arrowCanvas');
  const arrowCtx            = arrowCanvas.getContext('2d');

  // â”€â”€ Side-to-move toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let sideToMove = 'w';   // 'w' or 'b'

  sideWhiteBtn.addEventListener('click', () => {
    sideToMove = 'w';
    sideWhiteBtn.classList.add('active');
    sideBlackBtn.classList.remove('active');
    if (currentFen) analyzePosition(currentFen);
  });

  sideBlackBtn.addEventListener('click', () => {
    sideToMove = 'b';
    sideBlackBtn.classList.add('active');
    sideWhiteBtn.classList.remove('active');
    if (currentFen) analyzePosition(currentFen);
  });

  // â”€â”€ Engine init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function initEngine() {
    try {
      engine = new Worker('/static/stockfish.js');
    } catch (e) {
      console.error('Could not create Stockfish worker:', e);
      return;
    }
    engine.onmessage = handleEngineMessage;
    engine.postMessage('uci');
    engine.postMessage('setoption name MultiPV value 3');
    engine.postMessage('isready');
  }

  // â”€â”€ Message handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function handleEngineMessage(event) {
    const line = typeof event === 'string' ? event : (event.data || '');

    if (line === 'readyok') {
      engineReady = true;
      return;
    }

    if (line.startsWith('info') && line.includes('multipv')) {
      parseInfoLine(line);
      return;
    }

    if (line.startsWith('bestmove')) {
      renderResults();
    }
  }

  // â”€â”€ Parse UCI info line â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function parseInfoLine(line) {
    const depthMatch   = line.match(/\bdepth (\d+)/);
    const multipvMatch = line.match(/\bmultipv (\d+)/);
    const cpMatch      = line.match(/\bscore cp (-?\d+)/);
    const mateMatch    = line.match(/\bscore mate (-?\d+)/);
    const pvMatch      = line.match(/\bpv ([a-h][1-8][a-h][1-8][qrbn]?)/);

    if (!multipvMatch || !pvMatch) return;

    const depth = depthMatch ? parseInt(depthMatch[1]) : 0;
    const mpv   = parseInt(multipvMatch[1]);
    const move  = pvMatch[1];

    let score = cpMatch  ? parseInt(cpMatch[1])  : null;
    let mate  = mateMatch ? parseInt(mateMatch[1]) : null;

    if (depth < latestDepth) return;   // ignore stale depths
    latestDepth = depth;

    // Convert to White's POV (engine gives side-to-move POV)
    if (score !== null && sideToMove === 'b') score = -score;
    if (mate  !== null && sideToMove === 'b') mate  = -mate;

    // SAN conversion via chess.js
    let san = move;
    try {
      const fullFen = currentFen + ' ' + sideToMove + ' - - 0 1';
      const chess   = new Chess(fullFen);
      const result  = chess.move({ from: move.slice(0, 2), to: move.slice(2, 4), promotion: move[4] || 'q' });
      if (result) san = result.san;
    } catch (e) { /* keep UCI move as fallback */ }

    pendingResults[mpv] = { depth, move, san, score, mate };

    // Live depth label
    evalDepthLabel.textContent = 'depth ' + depth;
  }

  // â”€â”€ Arrow drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let lastArrowMoves = [];

  function squareCenter(sq, boardSize) {
    const sqSize = boardSize / 8;
    const file   = sq.charCodeAt(0) - 97;   // a=0 â€¦ h=7
    const rank   = parseInt(sq[1]);          // 1â€“8
    return {
      x: (file + 0.5) * sqSize,
      y: (8 - rank + 0.5) * sqSize          // rank 8 at top (yâ‰ˆ0), rank 1 at bottom
    };
  }

  function drawArrowShape(ctx, x1, y1, x2, y2, color, alpha, lw) {
    const angle   = Math.atan2(y2 - y1, x2 - x1);
    const headLen = lw * 2.8;
    // Shorten the shaft so the arrowhead sits cleanly at the tip
    const tx = x2 - Math.cos(angle) * headLen * 0.85;
    const ty = y2 - Math.sin(angle) * headLen * 0.85;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = color;
    ctx.fillStyle   = color;
    ctx.lineWidth   = lw;
    ctx.lineCap     = 'round';

    // Shaft
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(tx, ty);
    ctx.stroke();

    // Arrowhead (wider angle = more visible)
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 5),
               y2 - headLen * Math.sin(angle - Math.PI / 5));
    ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 5),
               y2 - headLen * Math.sin(angle + Math.PI / 5));
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawArrows(moves) {
    lastArrowMoves = moves;
    const boardEl = document.getElementById('board');
    const size    = boardEl.offsetWidth;
    arrowCanvas.width  = size;
    arrowCanvas.height = size;
    arrowCtx.clearRect(0, 0, size, size);

    const sq = size / 8;
    const styles = [
      { color: '#15781B', alpha: 0.88, lw: sq * 0.18  },  // best move â€” green
      { color: '#0057e7', alpha: 0.65, lw: sq * 0.13  },  // 2nd â€” blue
      { color: '#0057e7', alpha: 0.42, lw: sq * 0.10  },  // 3rd â€” blue (dim)
    ];

    moves.forEach(function (m, i) {
      if (i >= styles.length) return;
      const from = squareCenter(m.from, size);
      const to   = squareCenter(m.to,   size);
      const s    = styles[i];
      drawArrowShape(arrowCtx, from.x, from.y, to.x, to.y, s.color, s.alpha, s.lw);
    });
  }

  function clearArrows() {
    lastArrowMoves = [];
    arrowCtx.clearRect(0, 0, arrowCanvas.width, arrowCanvas.height);
  }

  // Redraw on resize (board.resize() changes the board's pixel size)
  window.addEventListener('resize', function () {
    if (lastArrowMoves.length) drawArrows(lastArrowMoves);
  });

  // â”€â”€ Render results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function renderResults() {
    const keys = Object.keys(pendingResults).map(Number).sort(function (a, b) { return a - b; });
    if (!keys.length) return;

    analysisPlaceholder.style.display = 'none';
    analysisContent.style.display     = 'block';

    const best = pendingResults[keys[0]];
    let cp = (best.mate !== null)
      ? (best.mate > 0 ? 1000 : -1000)
      : (best.score !== null ? best.score : 0);

    const whitePct = (Math.min(Math.max(cp, -1000), 1000) + 1000) / 2000 * 100;
    evalBarWhite.style.flex = String(whitePct);
    evalBarBlack.style.flex = String(100 - whitePct);

    if (best.mate !== null) {
      evalScoreLabel.textContent = 'M' + Math.abs(best.mate);
    } else {
      const s = best.score !== null ? best.score : 0;
      evalScoreLabel.textContent = (s >= 0 ? '+' : '') + (s / 100).toFixed(2);
    }

    movesBody.innerHTML = '';
    keys.forEach(function (k, i) {
      const r  = pendingResults[k];
      const tr = document.createElement('tr');
      let scoreText;
      if (r.mate !== null) {
        scoreText = 'M' + Math.abs(r.mate);
      } else {
        const s = r.score !== null ? r.score : 0;
        scoreText = (s >= 0 ? '+' : '') + (s / 100).toFixed(2);
      }
      tr.innerHTML =
        '<td>' + (i + 1) + '</td>' +
        '<td><span class="move-san">' + r.san + '</span></td>' +
        '<td class="move-score">' + scoreText + '</td>';
      movesBody.appendChild(tr);
    });

    evalDepthLabel.textContent = 'depth ' + best.depth + ' \u2014 done';

    // Draw arrows for top moves (UCI move format: "e2e4", "g1f3", etc.)
    drawArrows(keys.map(function (k) {
      const mv = pendingResults[k].move;
      return { from: mv.slice(0, 2), to: mv.slice(2, 4) };
    }));
  }

  // â”€â”€ Public: called after each detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  window.analyzePosition = function (piecePlacementFen) {
    currentFen     = piecePlacementFen;
    pendingResults = {};
    latestDepth    = 0;

    // Reset UI
    clearArrows();
    analysisPlaceholder.style.display = 'none';
    analysisContent.style.display     = 'block';
    evalDepthLabel.textContent        = 'depth 0';
    evalScoreLabel.textContent        = '\u2026';
    movesBody.innerHTML               = '';

    if (!engineReady) {
      evalDepthLabel.textContent = 'Engine loading\u2026';
      setTimeout(function () { window.analyzePosition(piecePlacementFen); }, 500);
      return;
    }

    const fullFen = piecePlacementFen + ' ' + sideToMove + ' - - 0 1';
    engine.postMessage('stop');
    engine.postMessage('position fen ' + fullFen);
    engine.postMessage('go depth 15');
  };

  // â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  initEngine();
})();
</script>

</body>
</html>
